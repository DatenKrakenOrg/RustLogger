use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use indexmap::IndexMap;
use std::fs;
use std::path::Path;

/// Configuration for a specific message type, loaded from TOML.
/// Defines the structure, field types, and generation behavior for log messages.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct MessageTypeConfig {
    /// Name of the message type (e.g., "iot_sensor", "system_metrics")
    pub name: String,
    /// Elasticsearch index name where logs of this type should be stored
    pub index_name: String,
    /// Human-readable description of what this message type represents
    pub description: String,
    /// Whether this message type should be generated by the log generator (defaults to true)
    pub generate: Option<bool>,
    /// Field definitions in the order they should appear in CSV output
    pub fields: IndexMap<String, FieldConfig>,
    /// Optional configuration for message type specific logic and thresholds
    pub logic: Option<HashMap<String, toml::Value>>,
}

/// Configuration for an individual field within a message type.
/// Specifies data type, constraints, and generation parameters.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct FieldConfig {
    /// Data type: "string", "integer", "float", "datetime", "enum", "uuid"
    pub r#type: String,
    /// For enum types: list of possible values to choose from
    pub values: Option<Vec<String>>,
    /// For numeric types: [min, max] range for generated values
    pub range: Option<Vec<f64>>,
    /// For string types: pattern with placeholders like "{id}" or "{prefix}"
    pub pattern: Option<String>,
    /// Unit of measurement (for documentation/metadata purposes)
    pub unit: Option<String>,
    /// Whether this field can be omitted (currently unused)
    pub optional: Option<bool>,
    /// For hex string generation: length of hex string (currently unused)
    pub hex_length: Option<u8>,
}

/// Root structure of the TOML configuration file.
#[derive(Debug, Deserialize)]
struct ConfigFile {
    message_types: Vec<MessageTypeConfig>,
}

/// Container for all loaded message type configurations.
/// Provides methods to access and query message types.
pub struct MessageTypesConfig {
    pub types: HashMap<String, MessageTypeConfig>,
}

impl MessageTypesConfig {
    /// Loads message type configurations from a TOML file.
    /// Only includes message types where `generate` is true or unspecified.
    /// 
    /// # Arguments
    /// * `path` - Path to the TOML configuration file
    /// 
    /// # Returns
    /// * `Result<Self, Box<dyn std::error::Error>>` - Loaded configuration or error
    pub fn load_from_file(path: &Path) -> Result<Self, Box<dyn std::error::Error>> {
        // Read and parse TOML file
        let content = fs::read_to_string(path)?;
        let config: ConfigFile = toml::from_str(&content)?;

        // Filter to only include message types that should be generated
        let config_types: Vec<MessageTypeConfig> = config.message_types.into_iter().filter(|msg_type| msg_type.generate.unwrap_or(true)).collect();
        
        // Build HashMap for fast lookup by name
        let mut types = HashMap::new();
        for message_type in config_types {
            types.insert(message_type.name.clone(), message_type);
        }
        
        Ok(MessageTypesConfig { types })
    }

    /// Retrieves a message type configuration by name.
    /// 
    /// # Arguments
    /// * `name` - Name of the message type to retrieve
    /// 
    /// # Returns
    /// * `Option<&MessageTypeConfig>` - The configuration if found, None otherwise
    pub fn get_type(&self, name: &str) -> Option<&MessageTypeConfig> {
        self.types.get(name)
    }

    /// Returns a list of all available message type names.
    /// 
    /// # Returns
    /// * `Vec<&String>` - Vector of message type names
    pub fn list_types(&self) -> Vec<&String> {
        self.types.keys().collect()
    }
}

/// Represents a generated field value that can be of various types.
/// Used to store generated data before conversion to CSV string format.
#[derive(Debug, Clone)]
pub enum FieldValue {
    /// Text/string value
    String(String),
    /// 64-bit integer value
    Integer(i64),
    /// 64-bit floating point value
    Float(f64),
    /// ISO 8601 formatted datetime string
    DateTime(String),
    /// UUID v4 string
    Uuid(String),
}

impl FieldValue {
    /// Converts the field value to a string representation suitable for CSV output.
    /// 
    /// # Returns
    /// * `String` - String representation of the value
    pub fn to_csv_string(&self) -> String {
        match self {
            FieldValue::String(s) => s.clone(),
            FieldValue::Integer(i) => i.to_string(),
            FieldValue::Float(f) => f.to_string(),

            FieldValue::DateTime(dt) => dt.clone(),
            FieldValue::Uuid(u) => u.clone(),
        }
    }
}
